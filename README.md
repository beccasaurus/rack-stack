RackStack
=========

`RackStack` is a fully managed stack of Rack applications (*inspired by [Rack::Builder][]*)

Installation
------------

Using Bundler:

```ruby
gem "rack-stack"
```

Or just `gem install rack-rack`

Usage
-----

```ruby
require "rack/stack" # or "rack-stack"

rack_stack = RackStack.new do
  use MyMiddleware
  map "/admin" do
    run AdminApp.new
  end
  run MyApp.new
end

# A RackStack instance is a Rack application, so you can #call it.
rack_stack.call(env)
```
If you're familar with Rack::Builder, that should look very familiar!

RackStack's API is actually intended to be [compatible with Rack::Builder's][compatibility].

RackStack offers a number of additional features:

 1. Conditional Logic
 1. Named Applications
 1. Stack Manipulation
 1. Use as Middleware

Uses Cases
----------

`TODO` reference sample use-cases (actual code / specs)

`TODO` add Rack::Proxy example to artifice example (for using real HTTP)

Conditional Logic
-----------------

RackStack allows you to easily add conditional logic for `:when` to `#run`, `#use`, or `#map` a rack component.

```ruby
RackStack.new do

  # When a block is given with 1 argument, the current request will be yielded (as a Rack::Request)
  use MyMiddleware, when: ->(request){ request.path_info =~ /about-us/ }

  # When a block is given with no arguments, the block is evaluated against the current request
  use MyMiddleware, when: ->{ path_info =~ /about-us/ }

  # When a Hash (or Array of pairs) is given, each value will be compared against the value from the 
  # current request.  In this example, the following would be evaluated: /about-us/ === "<the path info>"
  use MyMiddleware, when: { path_info: /about-us/ }

end
```

Named Applications
------------------

`TODO` Named Applications section

 - add names ...
 - remove ...
 - get access to...

Stack Manipulation
------------------

`TODO` Stack Manipulation section

A `RackStack` may be manipulated at runtime.

```ruby
rack_stack = RackStack.new

# You can run the RackStack or something else, eg. mount it with Artifice
some_rack_server.run(rack_stack)

# #use, #run, and #map may be used at runtime
rack_stack.use :my_middleware, SomeMiddleware
rack_stack.run SomeApp.new, when: { host: "someapp.com" }
rack_stack.map "/foo" do
  use FooMiddleware
  run FooApp.new
end

# Feel free to #remove named applications
rack_stack.remove :my_middleware

# You can also manipulate the stack Array directly.
#
# For example, if you want to put a #use statement *first*, you can:
rack_stack.stack.unshift RackStack.use(:my_middleware, SomeMiddleware)

# ...

# 
rack_stack.stack.insert 1, RackStack.use(:my_middleware, SomeMiddleware)
```

 - RackStack.use/map/run must be used to create the object to manually insert into RackStack#stack

Use as Middleware
-----------------

A Rack application generated by a Rack::Builder can only be run as a Rack endpoint,
not as a middleware.

RackStack can be run as either a Rack endpoint or a Rack middleware.

```ruby
# Example of using RackStack as a middleware (app built using an ordinary Rack::Builder)
Rack::Builder.new {

  use SomeMiddleware

  # RackStack can be used as a middleware, alongside your existing Rack components
  use RackStack.new when: { host: "foo.com" } do
    use AnotherMiddleware
    run SomeApplication.new
  end

  # Or RackStack can be used as a Rack endpoint.
  run RackStack.new do
    run AnotherApplication.new  
  end

}.to_app
```

`TODO` - add performance benchmark scripts (and maybe specs) ... find out if it's OK for real-world usage ... optimize ... generate numbers on what the overhead is like of having your middlewares hosted in a RackStack versus a regular application with middleware constructed normally.

[Rack::Builder]: http://rack.rubyforge.org/doc/classes/Rack/Builder.html
[compatibility]: https://github.com/remi/rack-stack/tree/master/spec/rack-builder-compatibility
